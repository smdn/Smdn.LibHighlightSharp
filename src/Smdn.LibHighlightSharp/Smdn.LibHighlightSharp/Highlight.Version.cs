// SPDX-FileCopyrightText: 2022 smdn <smdn@smdn.jp>
// SPDX-License-Identifier: GPL-3.0-or-later
using System;
using System.IO;
using System.Threading;

namespace Smdn.LibHighlightSharp;

#pragma warning disable IDE0040
partial class Highlight {
#pragma warning restore IDE0040
  // https://gitlab.com/saalen/highlight/-/blob/master/ChangeLog.adoc#user-content-highlight-3-44
  public static readonly Version MinimumVersionSupportingBase16Themes = new(3, 44);

  // https://gitlab.com/saalen/highlight/-/blob/master/ChangeLog.adoc#user-content-highlight-3-51
  // https://gitlab.com/saalen/highlight/-/commit/7196d734700d94c6d30bc6097c53db738bf05db6
  public static readonly Version MinimumVersionSupportingLoadFileTypesConfig = new(3, 51);
  public static readonly Version MinimumVersionSupportingGuessFileType = new(3, 51);

  private static void ThrowIfVersionNotSupported(
    string feature,
    Version minimumVersion
  )
  {
    if (minimumVersion <= VersionInformations.NativeLibraryVersion)
      return;

    throw new NotSupportedException(
      $"The requested feature or API '{feature}' is not supported with this version of the native library. (The version must be at least {minimumVersion} but the version of loaded native library is {VersionInformations.NativeLibraryVersion})"
    );
  }

  private string? GetGeneratorVersionString()
  {
    const string versionStringInvalid = "";

    using var hl = Create(outputType: GeneratorOutputType.Html);

    hl.Fragment = false;
    hl.OmitVersionComment = false;

    try {
      hl.SetTheme("github");
    }
    catch (HighlightThemeException) {
      return versionStringInvalid;
    }

    try {
      hl.SetSyntax("c");
    }
    catch (HighlightSyntaxException) {
      return versionStringInvalid;
    }

    var reader = new StringReader(hl.Generate("//"));

    for (; ; ) {
      var line = reader.ReadLine();

      if (line == null)
        return versionStringInvalid;

      const string prefix = "<!--HTML generated by ";
      const string suffix = "-->";

      if (
        line.StartsWith(prefix, StringComparison.Ordinal) &&
        line.EndsWith(suffix, StringComparison.Ordinal)
      ) {
        var versionString = line.Substring(prefix.Length); // trim prefix

        return versionString.Substring(0, versionString.Length - suffix.Length); // trim suffix
      }
    }
  }

  private string? generatorVersionString;

  public string? GeneratorVersionString {
    get {
      if (generatorVersionString is null)
        Interlocked.CompareExchange(ref generatorVersionString, GetGeneratorVersionString(), null);

      return generatorVersionString;
    }
  }
}
