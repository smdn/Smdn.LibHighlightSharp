// SPDX-FileCopyrightText: 2022 smdn <smdn@smdn.jp>
// SPDX-License-Identifier: GPL-3.0-or-later
using System;
using System.IO;
using System.Reflection;
using System.Threading;

namespace Smdn.LibHighlightSharp;

#pragma warning disable IDE0040
partial class Highlight {
#pragma warning restore IDE0040
  // https://gitlab.com/saalen/highlight/-/blob/master/ChangeLog.adoc#user-content-highlight-3-44
  public static readonly Version MinimumVersionSupportingBase16Themes = new(3, 44);

  // https://gitlab.com/saalen/highlight/-/blob/master/ChangeLog.adoc#user-content-highlight-3-51
  // https://gitlab.com/saalen/highlight/-/commit/7196d734700d94c6d30bc6097c53db738bf05db6
  public static readonly Version MinimumVersionSupportingLoadFileTypesConfig = new(3, 51);
  public static readonly Version MinimumVersionSupportingGuessFileType = new(3, 51);

  private static void ThrowIfVersionNotSupported(
    string feature,
    Version minimumVersion
  )
  {
    if (minimumVersion <= VersionInformations.NativeLibraryVersion)
      return;

    throw new NotSupportedException(
      $"The requested feature or API '{feature}' is not supported with this version of the native library. (The version must be at least {minimumVersion} but the version of loaded native library is {VersionInformations.NativeLibraryVersion})"
    );
  }

  private static void UseTempResourceFile<TArg>(
    string manifestResourceName,
    TArg arg,
    Action<string, TArg> actionUsingTempFile
  )
  {
    var executingAssembly = Assembly.GetExecutingAssembly();

    var resourceStream = executingAssembly.GetManifestResourceStream(manifestResourceName)
      ?? throw new InvalidOperationException($"manifest resource named with '{manifestResourceName}' did not find or is invisible.");
    var assemblyName = executingAssembly.GetName();
    var tempFilePath = Path.Combine(
      Path.GetTempPath(),
      $"{assemblyName.Name}-{assemblyName.Version}-{manifestResourceName}.tmp"
    );

    try {
      // write out a manifest resource to a file in the temporary directory
      using (var tempFileStream = File.OpenWrite(tempFilePath)) {
        tempFileStream.SetLength(0L);

        resourceStream.CopyTo(tempFileStream);

        tempFileStream.Flush();
      }

      actionUsingTempFile(tempFilePath, arg);
    }
    finally {
      File.Delete(tempFilePath);
    }
  }

  private static string? GetGeneratorInformationalVersion()
  {
    const string VersionStringInvalid = "";

    using var hl = new Highlight(outputType: GeneratorOutputType.Html);

    hl.Fragment = false;
    hl.OmitVersionComment = false;

    var executingAssembly = Assembly.GetExecutingAssembly();

    // write out a theme file to a temporary directory and load it
    try {
      UseTempResourceFile(
        "null.theme",
        hl,
        static (path, hl) => hl.SetThemeFromFile(path)
      );
    }
    catch (HighlightThemeException) {
      return VersionStringInvalid;
    }
    catch (IOException) {
      return VersionStringInvalid;
    }
    catch (UnauthorizedAccessException) {
      return VersionStringInvalid;
    }

    // write out a syntax file to a temporary directory and load it
    try {
      UseTempResourceFile(
        "null.lang",
        hl,
        static (path, hl) => hl.SetSyntaxFromFile(path)
      );
    }
    catch (HighlightSyntaxException) {
      return VersionStringInvalid;
    }
    catch (IOException) {
      return VersionStringInvalid;
    }
    catch (UnauthorizedAccessException) {
      return VersionStringInvalid;
    }

    var reader = new StringReader(hl.Generate("//"));

    for (; ; ) {
      var line = reader.ReadLine();

      if (line == null)
        return VersionStringInvalid;

      const string Prefix = "<!--HTML generated by ";
      const string Suffix = "-->";

      if (
        line.StartsWith(Prefix, StringComparison.Ordinal) &&
        line.EndsWith(Suffix, StringComparison.Ordinal)
      ) {
        var versionString = line.Substring(Prefix.Length); // trim prefix

        return versionString.Substring(0, versionString.Length - Suffix.Length); // trim suffix
      }
    }
  }

  private static string? generatorInformationalVersion;

  public static string? GeneratorInformationalVersion {
    get {
      if (generatorInformationalVersion is null)
        Interlocked.CompareExchange(ref generatorInformationalVersion, GetGeneratorInformationalVersion(), null);

      return generatorInformationalVersion;
    }
  }

  [Obsolete($"Use {nameof(GeneratorInformationalVersion)} instead.")]
  public string? GeneratorVersionString => GeneratorInformationalVersion;
}
